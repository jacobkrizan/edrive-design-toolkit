"""
Motor Meshing Module
Generates 2D mesh of motor cross-section using gmsh
Matches exact geometry from MotorDisplay class
"""

import sys
import os
import numpy as np
from typing import Optional
import subprocess

# Add gmsh to path
GMSH_PATH = os.path.join(os.path.dirname(__file__), 'gmsh', 'gmsh-4.13.1-Windows64')
GMSH_EXE = os.path.join(os.path.dirname(__file__), 'gmsh', 'gmsh.exe')

from part_classes import Motor


class MotorMesher:
    """Handles motor cross-section mesh generation using gmsh"""
    
    def __init__(self, motor: Motor):
        self.motor = motor
        self.mesh_size = 1.0  # mm - default element size
        self.geo_file = None
        self.msh_file = None
        
    def generate_mesh(self, mesh_size: float = 1.0, output_dir: Optional[str] = None) -> str:
        """
        Generate 2D mesh of motor cross-section
        
        Args:
            mesh_size: Target element size in mm
            output_dir: Directory to save mesh files (default: data directory)
            
        Returns:
            Path to generated .msh file
        """
        self.mesh_size = mesh_size
        
        if output_dir is None:
            output_dir = os.path.join(os.path.dirname(__file__), '..', 'data')
        
        os.makedirs(output_dir, exist_ok=True)
        
        # Generate geometry file
        self.geo_file = os.path.join(output_dir, 'motor_mesh.geo')
        self._write_geo_file(self.geo_file)
        
        # Generate mesh using gmsh executable
        self.msh_file = os.path.join(output_dir, 'motor_mesh.msh')
        self._generate_mesh_with_exe()
        
        return self.msh_file
    
    def _write_geo_file(self, filepath: str):
        """Write gmsh .geo geometry file - simple built-in kernel approach"""
        
        # Extract motor parameters
        stator = self.motor.stator
        rotor = self.motor.rotor
        
        # Get dimensions
        stator_od = stator.core.stator_core_outer_diameter if stator and stator.core else 200.0
        stator_id = stator.core.stator_core_inner_diameter if stator and stator.core else 148.0
        rotor_od = rotor.core.rotor_core_outer_diameter if rotor and rotor.core else 138.0
        rotor_id = rotor.core.rotor_core_inner_diameter if rotor and rotor.core else 50.0
        
        num_slots = int(stator.stator_slots) if stator and stator.stator_slots else 48
        num_poles = int(self.motor.motor_poles) if self.motor.motor_poles else 8
        
        slot_height = stator.core.stator_core_slot_height if stator and stator.core else 12.0
        slot_width = stator.core.stator_core_slot_width if stator and stator.core else 4.0
        
        magnet_thickness = rotor.magnet.magnet_thickness if rotor and rotor.magnet else 4.0
        magnet_arc_percent = rotor.magnet.magnet_arc_percent if rotor and rotor.magnet else 80.0
        
        # Calculate key radii
        stator_outer_r = stator_od / 2
        stator_inner_r = stator_id / 2
        slot_bottom_r = stator_inner_r
        slot_top_r = stator_inner_r + slot_height
        rotor_outer_r = rotor_od / 2
        rotor_inner_r = rotor_id / 2
        magnet_inner_r = rotor_outer_r
        magnet_outer_r = rotor_outer_r + magnet_thickness
        outer_air_inner_r = stator_outer_r
        outer_air_outer_r = stator_outer_r + 3.0  # 3mm past stator OD
        
        # Write .geo file - built-in kernel (simpler, no boolean issues)
        with open(filepath, 'w') as f:
            f.write("// Motor Cross-Section Geometry\n")
            f.write("// Auto-generated by MotorMesher\n\n")
            f.write(f"lc = {self.mesh_size};\n\n")
            
            # We'll create all regions as separate surfaces without boolean operations
            # This avoids the OpenCASCADE boolean operation errors
            
            # ======= Helper: Write circular region =======
            def write_annulus(f, name, inner_r, outer_r, center_id, pid, lid, loopid, surfid):
                """Write annular region - returns outer circle lines as last element of tuple"""
                # Outer circle
                f.write(f"Point({pid}) = {{{outer_r}, 0, 0, lc}};\n")
                f.write(f"Point({pid+1}) = {{0, {outer_r}, 0, lc}};\n")
                f.write(f"Point({pid+2}) = {{-{outer_r}, 0, 0, lc}};\n")
                f.write(f"Point({pid+3}) = {{0, -{outer_r}, 0, lc}};\n")
                
                f.write(f"Circle({lid}) = {{{pid}, {center_id}, {pid+1}}};\n")
                f.write(f"Circle({lid+1}) = {{{pid+1}, {center_id}, {pid+2}}};\n")
                f.write(f"Circle({lid+2}) = {{{pid+2}, {center_id}, {pid+3}}};\n")
                f.write(f"Circle({lid+3}) = {{{pid+3}, {center_id}, {pid}}};\n")
                f.write(f"Curve Loop({loopid}) = {{{lid}, {lid+1}, {lid+2}, {lid+3}}};\n")
                
                outer_lines = [lid, lid+1, lid+2, lid+3]  # Store outer boundary lines
                
                # Inner circle
                pid2 = pid + 10
                lid2 = lid + 10
                f.write(f"Point({pid2}) = {{{inner_r}, 0, 0, lc}};\n")
                f.write(f"Point({pid2+1}) = {{0, {inner_r}, 0, lc}};\n")
                f.write(f"Point({pid2+2}) = {{-{inner_r}, 0, 0, lc}};\n")
                f.write(f"Point({pid2+3}) = {{0, -{inner_r}, 0, lc}};\n")
                
                f.write(f"Circle({lid2}) = {{{pid2}, {center_id}, {pid2+1}}};\n")
                f.write(f"Circle({lid2+1}) = {{{pid2+1}, {center_id}, {pid2+2}}};\n")
                f.write(f"Circle({lid2+2}) = {{{pid2+2}, {center_id}, {pid2+3}}};\n")
                f.write(f"Circle({lid2+3}) = {{{pid2+3}, {center_id}, {pid2}}};\n")
                f.write(f"Curve Loop({loopid+1}) = {{{lid2}, {lid2+1}, {lid2+2}, {lid2+3}}};\n")
                
                f.write(f"Plane Surface({surfid}) = {{{loopid}, {loopid+1}}};\n\n")
                return pid2+10, lid2+10, loopid+2, surfid+1, outer_lines
            
            # Center point (shared by all circles)
            f.write("// Center point\n")
            f.write(f"Point(1) = {{0, 0, 0, lc}};\n\n")
            center_id = 1
            
            pid, lid, loopid, surfid = 10, 100, 1000, 1
            
            # Outer air region (3mm past stator OD)
            f.write("// Outer air region\n")
            pid, lid, loopid, surfid, outer_boundary_lines = write_annulus(f, "OuterAir", outer_air_inner_r, outer_air_outer_r,
                                                      center_id, pid, lid, loopid, surfid)
            outer_air_surf = surfid - 1
            
            # Stator yoke (outer ring)
            f.write("// Stator yoke\n")
            pid, lid, loopid, surfid, _ = write_annulus(f, "Stator", slot_top_r, stator_outer_r, 
                                                      center_id, pid, lid, loopid, surfid)
            stator_yoke_surf = surfid - 1
            
            # Stator teeth (ring from bore to slot bottom)
            f.write("// Stator teeth\n")
            pid, lid, loopid, surfid, _ = write_annulus(f, "Teeth", slot_bottom_r, slot_top_r,
                                                      center_id, pid, lid, loopid, surfid)
            stator_teeth_surf = surfid - 1
            
            # Airgap
            f.write("// Airgap\n")
            pid, lid, loopid, surfid, _ = write_annulus(f, "Airgap", magnet_outer_r, stator_inner_r,
                                                       center_id, pid, lid, loopid, surfid)
            airgap_surf = surfid - 1            # Rotor
            f.write("// Rotor core\n")
            pid, lid, loopid, surfid, _ = write_annulus(f, "Rotor", rotor_inner_r, rotor_outer_r,
                                                       center_id, pid, lid, loopid, surfid)
            rotor_surf = surfid - 1
            
            # Shaft (solid disk)
            f.write("// Shaft\n")
            shaft_pid = pid
            f.write(f"Point({shaft_pid}) = {{{rotor_inner_r}, 0, 0, lc}};\n")
            f.write(f"Point({shaft_pid+1}) = {{0, {rotor_inner_r}, 0, lc}};\n")
            f.write(f"Point({shaft_pid+2}) = {{-{rotor_inner_r}, 0, 0, lc}};\n")
            f.write(f"Point({shaft_pid+3}) = {{0, -{rotor_inner_r}, 0, lc}};\n")
            
            shaft_lid = lid
            f.write(f"Circle({shaft_lid}) = {{{shaft_pid}, {center_id}, {shaft_pid+1}}};\n")
            f.write(f"Circle({shaft_lid+1}) = {{{shaft_pid+1}, {center_id}, {shaft_pid+2}}};\n")
            f.write(f"Circle({shaft_lid+2}) = {{{shaft_pid+2}, {center_id}, {shaft_pid+3}}};\n")
            f.write(f"Circle({shaft_lid+3}) = {{{shaft_pid+3}, {center_id}, {shaft_pid}}};\n")
            f.write(f"Curve Loop({loopid}) = {{{shaft_lid}, {shaft_lid+1}, {shaft_lid+2}, {shaft_lid+3}}};\n")
            f.write(f"Plane Surface({surfid}) = {{{loopid}}};\n\n")
            shaft_surf = surfid
            
            pid = shaft_pid + 10
            lid = shaft_lid + 10
            loopid += 1
            surfid += 1
            
            # Slots
            f.write(f"// {num_slots} Slots\n")
            slot_surfs = []
            for i in range(num_slots):
                angle = 2 * np.pi * i / num_slots
                
                half_angle_bottom = slot_width / (2 * slot_bottom_r)
                half_angle_top = slot_width / (2 * slot_top_r)
                
                corners = [
                    (slot_bottom_r * np.cos(angle - half_angle_bottom), 
                     slot_bottom_r * np.sin(angle - half_angle_bottom)),
                    (slot_top_r * np.cos(angle - half_angle_top), 
                     slot_top_r * np.sin(angle - half_angle_top)),
                    (slot_top_r * np.cos(angle + half_angle_top), 
                     slot_top_r * np.sin(angle + half_angle_top)),
                    (slot_bottom_r * np.cos(angle + half_angle_bottom), 
                     slot_bottom_r * np.sin(angle + half_angle_bottom)),
                ]
                
                for j, (x, y) in enumerate(corners):
                    f.write(f"Point({pid + j}) = {{{x:.6f}, {y:.6f}, 0, lc}};\n")
                
                for j in range(4):
                    p1 = pid + j
                    p2 = pid + ((j + 1) % 4)
                    f.write(f"Line({lid + j}) = {{{p1}, {p2}}};\n")
                
                f.write(f"Curve Loop({loopid}) = {{{lid}, {lid+1}, {lid+2}, {lid+3}}};\n")
                f.write(f"Plane Surface({surfid}) = {{{loopid}}};\n")
                
                slot_surfs.append(surfid)
                pid += 10
                lid += 10
                loopid += 1
                surfid += 1
            
            f.write("\n")
            
            # Magnets
            f.write(f"// {num_poles} Magnets\n")
            magnet_surfs = []
            air_gap_magnet_surfs = []
            
            for i in range(num_poles):
                pole_angle = 2 * np.pi * i / num_poles
                magnet_arc_angle = (magnet_arc_percent / 100.0) * (2 * np.pi / num_poles)
                half_arc = magnet_arc_angle / 2
                pole_pitch_angle = 2 * np.pi / num_poles
                
                # Magnet region
                angle1 = pole_angle - half_arc
                angle2 = pole_angle + half_arc
                
                # 4 points for magnet wedge
                f.write(f"Point({pid}) = {{{magnet_inner_r * np.cos(angle1):.6f}, {magnet_inner_r * np.sin(angle1):.6f}, 0, lc}};\n")
                f.write(f"Point({pid+1}) = {{{magnet_outer_r * np.cos(angle1):.6f}, {magnet_outer_r * np.sin(angle1):.6f}, 0, lc}};\n")
                f.write(f"Point({pid+2}) = {{{magnet_outer_r * np.cos(angle2):.6f}, {magnet_outer_r * np.sin(angle2):.6f}, 0, lc}};\n")
                f.write(f"Point({pid+3}) = {{{magnet_inner_r * np.cos(angle2):.6f}, {magnet_inner_r * np.sin(angle2):.6f}, 0, lc}};\n")
                
                # 4 lines: radial, arc, radial, arc
                f.write(f"Line({lid}) = {{{pid}, {pid+1}}};\n")
                f.write(f"Circle({lid+1}) = {{{pid+1}, {center_id}, {pid+2}}};\n")
                f.write(f"Line({lid+2}) = {{{pid+2}, {pid+3}}};\n")
                f.write(f"Circle({lid+3}) = {{{pid+3}, {center_id}, {pid}}};\n")
                
                f.write(f"Curve Loop({loopid}) = {{{lid}, {lid+1}, {lid+2}, {lid+3}}};\n")
                f.write(f"Plane Surface({surfid}) = {{{loopid}}};\n")
                
                magnet_surfs.append(surfid)
                pid += 10
                lid += 10
                loopid += 1
                surfid += 1
                
                # Air gap between magnets (if magnets don't cover full pole pitch)
                if magnet_arc_percent < 100:
                    # Next pole angle
                    next_pole_angle = pole_angle + pole_pitch_angle
                    next_angle1 = next_pole_angle - half_arc
                    
                    # Air gap from current magnet end to next magnet start
                    air_angle1 = angle2
                    air_angle2 = next_angle1
                    
                    # 4 points for air gap wedge
                    f.write(f"Point({pid}) = {{{magnet_inner_r * np.cos(air_angle1):.6f}, {magnet_inner_r * np.sin(air_angle1):.6f}, 0, lc}};\n")
                    f.write(f"Point({pid+1}) = {{{magnet_outer_r * np.cos(air_angle1):.6f}, {magnet_outer_r * np.sin(air_angle1):.6f}, 0, lc}};\n")
                    f.write(f"Point({pid+2}) = {{{magnet_outer_r * np.cos(air_angle2):.6f}, {magnet_outer_r * np.sin(air_angle2):.6f}, 0, lc}};\n")
                    f.write(f"Point({pid+3}) = {{{magnet_inner_r * np.cos(air_angle2):.6f}, {magnet_inner_r * np.sin(air_angle2):.6f}, 0, lc}};\n")
                    
                    # 4 lines
                    f.write(f"Line({lid}) = {{{pid}, {pid+1}}};\n")
                    f.write(f"Circle({lid+1}) = {{{pid+1}, {center_id}, {pid+2}}};\n")
                    f.write(f"Line({lid+2}) = {{{pid+2}, {pid+3}}};\n")
                    f.write(f"Circle({lid+3}) = {{{pid+3}, {center_id}, {pid}}};\n")
                    
                    f.write(f"Curve Loop({loopid}) = {{{lid}, {lid+1}, {lid+2}, {lid+3}}};\n")
                    f.write(f"Plane Surface({surfid}) = {{{loopid}}};\n")
                    
                    air_gap_magnet_surfs.append(surfid)
                    pid += 10
                    lid += 10
                    loopid += 1
                    surfid += 1
            
            f.write("\n")
            
            # Physical surfaces
            f.write("// Physical surfaces\n")
            f.write(f"Physical Surface(\"Outer_Air\", 1) = {{{outer_air_surf}}};\n")
            f.write(f"Physical Surface(\"Stator_Yoke\", 2) = {{{stator_yoke_surf}}};\n")
            f.write(f"Physical Surface(\"Stator_Teeth\", 3) = {{{stator_teeth_surf}}};\n")
            f.write(f"Physical Surface(\"Slots\", 4) = {{{', '.join(str(s) for s in slot_surfs)}}};\n")
            f.write(f"Physical Surface(\"Airgap\", 5) = {{{airgap_surf}}};\n")
            f.write(f"Physical Surface(\"Magnets\", 6) = {{{', '.join(str(s) for s in magnet_surfs)}}};\n")
            if air_gap_magnet_surfs:
                f.write(f"Physical Surface(\"Air_Between_Magnets\", 7) = {{{', '.join(str(s) for s in air_gap_magnet_surfs)}}};\n")
            f.write(f"Physical Surface(\"Rotor\", 8) = {{{rotor_surf}}};\n")
            f.write(f"Physical Surface(\"Shaft\", 9) = {{{shaft_surf}}};\n\n")
            
            # Physical line for outer boundary condition
            f.write("// Physical line for boundary condition (outer edge of OuterAir)\n")
            boundary_lines_str = ", ".join(map(str, outer_boundary_lines))
            f.write(f"Physical Line(\"OuterBoundary\", 1001) = {{{boundary_lines_str}}};\n\n")
            
            # Mesh settings
            f.write("// Mesh settings\n")
            f.write("Mesh.CharacteristicLengthMin = lc/2;\n")
            f.write("Mesh.CharacteristicLengthMax = lc*2;\n")
            f.write("Mesh.Algorithm = 6;\n")
    
    def _generate_mesh_with_exe(self):
        """Generate mesh using gmsh executable"""
        if not os.path.exists(GMSH_EXE):
            raise FileNotFoundError(f"gmsh executable not found at {GMSH_EXE}")
        
        # Run gmsh to generate mesh
        cmd = [GMSH_EXE, self.geo_file, "-2", "-o", self.msh_file, "-format", "msh2"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            raise RuntimeError(f"gmsh meshing failed: {result.stderr}")
    
    def open_in_viewer(self, mesh_file: Optional[str] = None):
        """
        Open mesh in gmsh GUI viewer
        
        Args:
            mesh_file: Path to .msh file (defaults to last generated mesh)
        """
        if mesh_file is None:
            mesh_file = self.msh_file
        
        if not mesh_file or not os.path.exists(mesh_file):
            raise FileNotFoundError(f"Mesh file not found: {mesh_file}")
        
        if not os.path.exists(GMSH_EXE):
            raise FileNotFoundError(f"gmsh executable not found at {GMSH_EXE}")
        
        # Open gmsh viewer
        subprocess.Popen([GMSH_EXE, mesh_file])


def mesh_motor(motor: Motor, mesh_size: float = 1.0, show_viewer: bool = True) -> str:
    """
    Convenience function to mesh motor and optionally display
    
    Args:
        motor: Motor object to mesh
        mesh_size: Target element size in mm
        show_viewer: Whether to open gmsh viewer
        
    Returns:
        Path to generated mesh file
    """
    mesher = MotorMesher(motor)
    mesh_file = mesher.generate_mesh(mesh_size=mesh_size)
    
    if show_viewer:
        mesher.open_in_viewer(mesh_file)
    
    return mesh_file
